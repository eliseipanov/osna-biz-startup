This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: bot/**, core/models.py
- Files matching these patterns are excluded: static/**, .venv/**, **/__pycache__/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
bot/
  handlers/
    start.py
    store.py
  keyboards/
    main_menu.py
  main.py
core/
  models.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="bot/handlers/store.py">
import sqlalchemy
from aiogram import Router, F, types
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, FSInputFile
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from sqlalchemy.orm import joinedload
from core.database import async_session
from core.models import Category, Product, CartItem, User, Translation, AvailabilityStatus
from datetime import datetime
import os

router = Router()

# Helper function to check if message matches translation
async def matches_translation(message_text: str, translation_key: str) -> bool:
    """Check if message matches any translation for the given key in both languages."""
    try:
        async with async_session() as session:
            translation = await session.scalar(
                select(Translation).where(Translation.key == translation_key)
            )
            if translation:
                return (message_text == translation.value_uk or
                        message_text == translation.value_de)
    except Exception as e:
        print(f"Error checking translation for {translation_key}: {e}")
    return False

# Helper function to get translation for current user language
async def get_translation(translation_key: str, user_language: str = "uk") -> str:
    """Get translation for the given key in user's language."""
    try:
        async with async_session() as session:
            translation = await session.scalar(
                select(Translation).where(Translation.key == translation_key)
            )
            if translation:
                if user_language == "de" and translation.value_de:
                    return translation.value_de
                return translation.value_uk or translation_key
    except Exception as e:
        print(f"Error getting translation for {translation_key}: {e}")
    return translation_key

# Helper function to get localized product name
def get_localized_product_name(product: Product, language: str = "uk") -> str:
    """Get product name in user's language, fallback to Ukrainian if German not available."""
    if language == "de" and product.name_de:
        return product.name_de
    return product.name or "Unnamed Product"

# Helper function to get localized product description
def get_localized_product_description(product: Product, language: str = "uk") -> str:
    """Get product description in user's language, fallback to Ukrainian if German not available."""
    if language == "de" and product.description_de:
        return product.description_de
    return product.description or ""

# Helper function to check if orders are allowed

def is_order_allowed():
    now = datetime.now()
    # Friday 12:00 in Europe/Berlin timezone (UTC+1)
    deadline = datetime.now().replace(hour=12, minute=0, second=0, microsecond=0)
    # Check if today is Friday (4) and current time is past deadline
    if now.weekday() == 4 and now > deadline:
        return False
    return True

# Category selection handler

def get_categories_keyboard():
    builder = InlineKeyboardBuilder()
    # Add categories dynamically from database
    # This will be populated in the actual handler
    return builder.as_markup()

@router.message()
async def handle_catalog_message(message: Message):
    """Handle catalog button clicks in both languages."""
    if await matches_translation(message.text, "catalog_button"):
        await show_categories(message)
    try:
        async with async_session() as session:
            # Get all categories
            categories = await session.scalars(select(Category))
            categories = categories.all()
            
            if not categories:
                await message.answer("–ö–∞—Ç–µ–≥–æ—Ä—ñ—ó –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                return
            
            # Create inline keyboard with categories
            builder = InlineKeyboardBuilder()
            for category in categories:
                builder.button(
                    text=category.name,
                    callback_data=f"category_{category.id}"
                )
            
            builder.adjust(2)  # 2 columns
            
            await message.answer(
                "ü•© <b>–û–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é:</b>",
                reply_markup=builder.as_markup(),
                parse_mode="HTML"
            )
    except Exception as e:
        await message.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π.")

# Category callback handler
@router.callback_query(F.data.startswith("category_"))
async def show_category_products(callback: CallbackQuery):
    try:
        category_id = int(callback.data.split("_")[1])

        async with async_session() as session:
            # Get user language preference
            user = await session.scalar(select(User).where(User.tg_id == callback.from_user.id))
            user_language = user.language_pref if user else "uk"

            # Get category and its products
            category = await session.get(Category, category_id)
            if not category:
                error_msg = "–ö–∞—Ç–µ–≥–æ—Ä—ñ—é –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ." if user_language == "uk" else "Kategorie nicht gefunden."
                await callback.answer(error_msg)
                return

            # Get products in this category that are in stock
            products = await session.scalars(
                select(Product)
                .where(Product.category_id == category_id)
                .where(Product.availability_status == AvailabilityStatus.IN_STOCK)
            )
            products = products.all()

            if not products:
                error_msg = "–£ —Ü—ñ–π –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –Ω–µ–º–∞—î —Ç–æ–≤–∞—Ä—ñ–≤." if user_language == "uk" else "Keine Produkte in dieser Kategorie."
                await callback.answer(error_msg)
                return

            # Send products as cards
            for product in products:
                try:
                    # Build product card caption with localized content
                    product_name = get_localized_product_name(product, user_language)
                    product_description = get_localized_product_description(product, user_language)

                    caption = f"<b>{product_name}</b>\n\n"
                    if product_description:
                        caption += f"{product_description}\n\n"
                    caption += f"üí∂ –¶—ñ–Ω–∞: {product.price} ‚Ç¨/{product.unit}"

                    # Create inline keyboard for quantity control
                    builder = InlineKeyboardBuilder()

                    # Check if user has this product in cart
                    user_cart_item = await session.scalar(
                        select(CartItem)
                        .where(CartItem.user_id == callback.from_user.id)
                        .where(CartItem.product_id == product.id)
                    )

                    current_quantity = user_cart_item.quantity if user_cart_item else 0

                    # Add quantity control buttons
                    if is_order_allowed():
                        builder.button(text="-", callback_data=f"decrease_{product.id}")
                        builder.button(text=f"–í –∫–æ—à–∏–∫—É: {current_quantity}", callback_data="qty")
                        builder.button(text="+", callback_data=f"increase_{product.id}")
                    else:
                        builder.button(text="-", callback_data="disabled")
                        builder.button(text=f"–í –∫–æ—à–∏–∫—É: {current_quantity}", callback_data="qty")
                        builder.button(text="+", callback_data="disabled")

                    builder.adjust(3)

                    # Add navigation buttons
                    builder.row()
                    back_text = "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –¥–æ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π" if user_language == "uk" else "‚¨ÖÔ∏è Zur√ºck zu Kategorien"
                    builder.button(text=back_text, callback_data="back_to_categories")

                    # Check if user has items in cart
                    cart_count = await session.scalar(
                        select(sqlalchemy.func.count())
                        .select_from(CartItem)
                        .where(CartItem.user_id == callback.from_user.id)
                    )

                    if cart_count > 0:
                        cart_text = "üõí –ü–µ—Ä–µ–π—Ç–∏ –¥–æ –∫–æ—à–∏–∫–∞" if user_language == "uk" else "üõí Zum Warenkorb"
                        builder.button(text=cart_text, callback_data="go_to_cart")

                    # Send product card with better error handling
                    try:
                        if product.image_path and os.path.exists(f"static/uploads/{product.image_path}"):
                            photo = FSInputFile(f"static/uploads/{product.image_path}")
                            await callback.message.answer_photo(
                                photo=photo,
                                caption=caption,
                                reply_markup=builder.as_markup(),
                                parse_mode="HTML"
                            )
                        else:
                            # Send text-only message if no image
                            await callback.message.answer(
                                caption,
                                reply_markup=builder.as_markup(),
                                parse_mode="HTML"
                            )
                    except Exception as image_error:
                        # If image sending fails, send text-only as fallback
                        print(f"Image error for product {product.id}: {image_error}")
                        await callback.message.answer(
                            caption,
                            reply_markup=builder.as_markup(),
                            parse_mode="HTML"
                        )

                except Exception as product_error:
                    print(f"Error displaying product {product.id}: {product_error}")
                    # Continue with next product instead of failing completely
                    continue

            await callback.answer()
    except Exception as e:
        print(f"Error in show_category_products: {e}")
        await callback.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ç–æ–≤–∞—Ä—ñ–≤.")

# Quantity control handlers
@router.callback_query(F.data.startswith("increase_"))
async def increase_quantity(callback: CallbackQuery):
    if not is_order_allowed():
        await callback.answer("–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è –Ω–∞ —Ü—é —Å—É–±–æ—Ç—É –∑–∞–∫—Ä–∏—Ç–æ!", show_alert=True)
        return
    
    try:
        product_id = int(callback.data.split("_")[1])
        user_id = callback.from_user.id
        
        async with async_session() as session:
            # Get or create cart item
            cart_item = await session.scalar(
                select(CartItem)
                .where(CartItem.user_id == user_id)
                .where(CartItem.product_id == product_id)
            )
            
            if cart_item:
                cart_item.quantity += 1.0
            else:
                cart_item = CartItem(
                    user_id=user_id,
                    product_id=product_id,
                    quantity=1.0
                )
                session.add(cart_item)
            
            await session.commit()
            
            # Update message to show new quantity
            await update_product_message(callback.message, product_id, user_id)
            await callback.answer(f"–î–æ–¥–∞–Ω–æ –¥–æ –∫–æ—à–∏–∫–∞. –ö—ñ–ª—å–∫—ñ—Å—Ç—å: {cart_item.quantity}")
    except Exception as e:
        await callback.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ –∫–æ—à–∏–∫–∞.")

@router.callback_query(F.data.startswith("decrease_"))
async def decrease_quantity(callback: CallbackQuery):
    try:
        product_id = int(callback.data.split("_")[1])
        user_id = callback.from_user.id
        
        async with async_session() as session:
            # Get cart item
            cart_item = await session.scalar(
                select(CartItem)
                .where(CartItem.user_id == user_id)
                .where(CartItem.product_id == product_id)
            )
            
            if cart_item:
                if cart_item.quantity > 1:
                    cart_item.quantity -= 1.0
                    await session.commit()
                    
                    # Update message to show new quantity
                    await update_product_message(callback.message, product_id, user_id)
                    await callback.answer(f"–ó–º–µ–Ω—à–µ–Ω–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å. –ö—ñ–ª—å–∫—ñ—Å—Ç—å: {cart_item.quantity}")
                else:
                    await session.delete(cart_item)
                    await session.commit()
                    
                    # Update message to show new quantity
                    await update_product_message(callback.message, product_id, user_id)
                    await callback.answer("–¢–æ–≤–∞—Ä –≤–∏–¥–∞–ª–µ–Ω–æ –∑ –∫–æ—à–∏–∫–∞.")
            else:
                await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –∫–æ—à–∏–∫—É.")
    except Exception as e:
        await callback.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ –∫–æ—à–∏–∫–∞.")

# Navigation handlers
@router.callback_query(F.data == "back_to_categories")
async def back_to_categories(callback: CallbackQuery):
    try:
        async with async_session() as session:
            # Get all categories
            categories = await session.scalars(select(Category))
            categories = categories.all()
            
            if not categories:
                await callback.answer("–ö–∞—Ç–µ–≥–æ—Ä—ñ—ó –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                return
            
            # Create inline keyboard with categories
            builder = InlineKeyboardBuilder()
            for category in categories:
                builder.button(
                    text=category.name,
                    callback_data=f"category_{category.id}"
                )
            
            builder.adjust(2)  # 2 columns
            
            await callback.message.edit_text(
                "ü•© <b>–û–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é:</b>",
                reply_markup=builder.as_markup(),
                parse_mode="HTML"
            )
            await callback.answer()
    except Exception as e:
        await callback.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—ñ –¥–æ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π.")

@router.callback_query(F.data == "go_to_cart")
async def go_to_cart(callback: CallbackQuery):
    await callback.answer("–§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª –∫–æ—à–∏–∫–∞ —â–µ –Ω–µ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ.")

# Helper function to update product message with new quantity
async def update_product_message(message: Message, product_id: int, user_id: int):
    try:
        async with async_session() as session:
            # Get user language preference
            user = await session.scalar(select(User).where(User.tg_id == user_id))
            user_language = user.language_pref if user else "uk"

            # Get product and cart item
            product = await session.get(Product, product_id)
            cart_item = await session.scalar(
                select(CartItem)
                .where(CartItem.user_id == user_id)
                .where(CartItem.product_id == product_id)
            )

            if not product:
                return

            current_quantity = cart_item.quantity if cart_item else 0

            # Build updated caption with localized content
            product_name = get_localized_product_name(product, user_language)
            product_description = get_localized_product_description(product, user_language)

            caption = f"<b>{product_name}</b>\n\n"
            if product_description:
                caption += f"{product_description}\n\n"
            caption += f"üí∂ –¶—ñ–Ω–∞: {product.price} ‚Ç¨/{product.unit}"

            # Create updated inline keyboard
            builder = InlineKeyboardBuilder()

            if is_order_allowed():
                builder.button(text="-", callback_data=f"decrease_{product.id}")
                cart_text = f"–í –∫–æ—à–∏–∫—É: {current_quantity}" if user_language == "uk" else f"Im Warenkorb: {current_quantity}"
                builder.button(text=cart_text, callback_data="qty")
                builder.button(text="+", callback_data=f"increase_{product.id}")
            else:
                builder.button(text="-", callback_data="disabled")
                cart_text = f"–í –∫–æ—à–∏–∫—É: {current_quantity}" if user_language == "uk" else f"Im Warenkorb: {current_quantity}"
                builder.button(text=cart_text, callback_data="qty")
                builder.button(text="+", callback_data="disabled")

            builder.adjust(3)

            # Add navigation buttons
            builder.row()
            back_text = "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –¥–æ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π" if user_language == "uk" else "‚¨ÖÔ∏è Zur√ºck zu Kategorien"
            builder.button(text=back_text, callback_data="back_to_categories")

            # Check if user has items in cart
            cart_count = await session.scalar(
                select(sqlalchemy.func.count())
                .select_from(CartItem)
                .where(CartItem.user_id == user_id)
            )

            if cart_count > 0:
                cart_btn_text = "üõí –ü–µ—Ä–µ–π—Ç–∏ –¥–æ –∫–æ—à–∏–∫–∞" if user_language == "uk" else "üõí Zum Warenkorb"
                builder.button(text=cart_btn_text, callback_data="go_to_cart")

            # Edit the original message with better error handling
            try:
                if product.image_path and os.path.exists(f"static/uploads/{product.image_path}"):
                    await message.edit_caption(
                        caption=caption,
                        reply_markup=builder.as_markup(),
                        parse_mode="HTML"
                    )
                else:
                    await message.edit_text(
                        text=caption,
                        reply_markup=builder.as_markup(),
                        parse_mode="HTML"
                    )
            except Exception as edit_error:
                print(f"Error editing message for product {product_id}: {edit_error}")
    except Exception as e:
        print(f"Error updating product message: {e}")
</file>

<file path="bot/keyboards/main_menu.py">
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from sqlalchemy import select
from core.database import async_session
from core.models import Translation

async def get_main_menu_keyboard(user_language="uk"):
    """Get main menu keyboard with localized button labels from database."""
    try:
        async with async_session() as session:
            # Fetch translations for main menu buttons
            catalog_trans = await session.scalar(
                select(Translation).where(Translation.key == "catalog_button")
            )
            profile_trans = await session.scalar(
                select(Translation).where(Translation.key == "profile_button")
            )
            impressum_trans = await session.scalar(
                select(Translation).where(Translation.key == "impressum_button")
            )

            # Get localized text based on user language
            catalog_text = (catalog_trans.value_de if user_language == "de" and catalog_trans.value_de
                          else catalog_trans.value_uk if catalog_trans else "ü•© Catalog")

            profile_text = (profile_trans.value_de if user_language == "de" and profile_trans.value_de
                          else profile_trans.value_uk if profile_trans else "üë§ Profile")

            impressum_text = (impressum_trans.value_de if user_language == "de" and impressum_trans.value_de
                            else impressum_trans.value_uk if impressum_trans else "‚ÑπÔ∏è Impressum")

            # Add WebApp placeholder to catalog button
            catalog_text += " (WebApp Placeholder)"

            keyboard = [
                [KeyboardButton(text=catalog_text)],
                [KeyboardButton(text=profile_text)],
                [KeyboardButton(text=impressum_text)]
            ]
            return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, persistent=True)
    except Exception as e:
        # Fallback to hardcoded English if database error
        keyboard = [
            [KeyboardButton(text="ü•© Catalog (WebApp Placeholder)")],
            [KeyboardButton(text="üë§ Profile")],
            [KeyboardButton(text="‚ÑπÔ∏è Impressum")]
        ]
        return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, persistent=True)

# Backward compatibility function
def get_main_menu_keyboard():
    """Synchronous fallback for backward compatibility."""
    import asyncio
    try:
        # Try to get event loop
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # If loop is running, we can't call async function directly
            # Return fallback keyboard
            keyboard = [
                [KeyboardButton(text="ü•© Catalog (WebApp Placeholder)")],
                [KeyboardButton(text="üë§ Profile")],
                [KeyboardButton(text="‚ÑπÔ∏è Impressum")]
            ]
            return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, persistent=True)
        else:
            # Create new event loop
            return loop.run_until_complete(get_main_menu_keyboard_async())
    except RuntimeError:
        # No event loop, return fallback
        keyboard = [
            [KeyboardButton(text="ü•© Catalog (WebApp Placeholder)")],
            [KeyboardButton(text="üë§ Profile")],
            [KeyboardButton(text="‚ÑπÔ∏è Impressum")]
        ]
        return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, persistent=True)
</file>

<file path="bot/main.py">
import asyncio
import os
from dotenv import load_dotenv
from aiogram import Bot, Dispatcher

from bot.handlers.start import router as start_router
from bot.handlers.store import router as store_router

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

dp.include_router(start_router)
dp.include_router(store_router)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="bot/handlers/start.py">
from aiogram import Router, F
from aiogram.filters import Command, BaseFilter
from aiogram.types import Message, CallbackQuery, ReplyKeyboardMarkup, KeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.keyboard import InlineKeyboardBuilder

from sqlalchemy import select

from core.database import async_session
from core.models import User, StaticPage, Translation
from bot.keyboards.main_menu import get_main_menu_keyboard

# Custom Translation Filter for multilingual button handling
class TranslationFilter(BaseFilter):
    def __init__(self, key: str):
        self.key = key

    async def __call__(self, message: Message) -> bool:
        async with async_session() as session:
            trans = await session.scalar(select(Translation).where(Translation.key == self.key))
            if not trans: return False
            return message.text in [trans.value_uk, trans.value_de]

router = Router()

# Helper function to check if message matches translation
async def matches_translation(message_text: str, translation_key: str) -> bool:
    """Check if message matches any translation for the given key in both languages."""
    try:
        async with async_session() as session:
            translation = await session.scalar(
                select(Translation).where(Translation.key == translation_key)
            )
            if translation:
                return (message_text == translation.value_uk or
                        message_text == translation.value_de)
    except Exception as e:
        print(f"Error checking translation for {translation_key}: {e}")
    return False

# Helper function to get translation for current user language
async def get_translation(translation_key: str, user_language: str = "uk") -> str:
    """Get translation for the given key in user's language."""
    try:
        async with async_session() as session:
            translation = await session.scalar(
                select(Translation).where(Translation.key == translation_key)
            )
            if translation:
                if user_language == "de" and translation.value_de:
                    return translation.value_de
                return translation.value_uk or translation_key
    except Exception as e:
        print(f"Error getting translation for {translation_key}: {e}")
    return translation_key

# FSM States for onboarding
class OnboardingStates(StatesGroup):
    waiting_for_language = State()
    waiting_for_agreement = State()
    waiting_for_name_confirmation = State()
    waiting_for_name_input = State()
    waiting_for_phone = State()

@router.message(Command("start"))
async def start_handler(message: Message, state: FSMContext):
    tg_id = message.from_user.id
    full_name = message.from_user.full_name

    try:
        async with async_session() as session:
            user = await session.scalar(select(User).where(User.tg_id == tg_id))

            # If user exists and has completed onboarding (has phone), show main menu
            if user and user.phone:
                main_menu = await get_main_menu_keyboard(user.language_pref or "uk")
                welcome_text = await get_translation("welcome_message", user.language_pref or "uk")
                await message.answer(f"{welcome_text} –û–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–¥—ñ–ª –Ω–∏–∂—á–µ üëá", reply_markup=main_menu)
                return

            # Start onboarding flow for new users or incomplete profiles
            await state.update_data(tg_id=tg_id, full_name=full_name)

            # Language selection
            builder = InlineKeyboardBuilder()
            builder.button(text="üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", callback_data="lang_uk")
            builder.button(text="üá©üá™ Deutsch", callback_data="lang_de")

            await message.answer(
                "üåç <b>–í–∏–±–µ—Ä—ñ—Ç—å –º–æ–≤—É / Choose language:</b>\n\n"
                "üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞\n"
                "üá©üá™ Deutsch",
                reply_markup=builder.as_markup(),
                parse_mode="HTML"
            )
            await state.set_state(OnboardingStates.waiting_for_language)

    except Exception as e:
        await message.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")

# Language selection callback
@router.callback_query(OnboardingStates.waiting_for_language, F.data.startswith("lang_"))
async def process_language(callback: CallbackQuery, state: FSMContext):
    language = callback.data.split("_")[1]  # "uk" or "de"
    await state.update_data(language_pref=language)

    # Save language preference immediately to database
    data = await state.get_data()
    try:
        async with async_session() as session:
            # Get or create user
            user = await session.scalar(select(User).where(User.tg_id == data["tg_id"]))

            if not user:
                user = User(
                    tg_id=data["tg_id"],
                    full_name=data["full_name"]
                )
                session.add(user)

            # Save language preference immediately
            user.language_pref = language
            await session.commit()
    except Exception as e:
        # Continue with onboarding even if DB save fails
        pass

    # Show legal agreement
    if language == "uk":
        text = (
            "üìã <b>–ü—Ä–∞–≤–∏–ª–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏</b>\n\n"
            "–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ –¥–æ Osnabr√ºck Farm Connect!\n\n"
            "–¶—è —Å–∏—Å—Ç–µ–º–∞ –¥–æ–ø–æ–º–∞–≥–∞—î –º—ñ—Å—Ü–µ–≤–∏–º —Ñ–µ—Ä–º–µ—Ä–∞–º –∑ –û—Å–Ω–∞–±—Ä—é–∫–∞ "
            "–ø—Ä–æ–¥–∞–≤–∞—Ç–∏ —Å–≤—ñ–∂—ñ –ø—Ä–æ–¥—É–∫—Ç–∏ —É–∫—Ä–∞—ó–Ω—Å—å–∫—ñ–π –≥—Ä–æ–º–∞–¥—ñ.\n\n"
            "üîí <b>–ü–æ–ª—ñ—Ç–∏–∫–∞ –∫–æ–Ω—Ñ—ñ–¥–µ–Ω—Ü—ñ–π–Ω–æ—Å—Ç—ñ:</b>\n"
            "–í–∞—à—ñ –¥–∞–Ω—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –∑–∞–º–æ–≤–ª–µ–Ω—å.\n\n"
            "üìû <b>–ö–æ–Ω—Ç–∞–∫—Ç–∏:</b>\n"
            "–î–ª—è –ø–∏—Ç–∞–Ω—å –∑–≤–µ—Ä—Ç–∞–π—Ç–µ—Å—è –¥–æ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\n\n"
            "–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ, —â–æ–± –ø–æ–≥–æ–¥–∏—Ç–∏—Å—è –∑ –ø—Ä–∞–≤–∏–ª–∞–º–∏."
        )
        agree_text = "‚úÖ –ó–≥–æ–¥–µ–Ω –∑ –ø—Ä–∞–≤–∏–ª–∞–º–∏"
    else:
        text = (
            "üìã <b>Nutzungsbedingungen</b>\n\n"
            "Willkommen bei Osnabr√ºck Farm Connect!\n\n"
            "Dieses System hilft lokalen Bauern aus Osnabr√ºck, "
            "frische Produkte an die ukrainische Gemeinschaft zu verkaufen.\n\n"
            "üîí <b>Datenschutz:</b>\n"
            "Ihre Daten werden nur zur Auftragsabwicklung verwendet.\n\n"
            "üìû <b>Kontakte:</b>\n"
            "Bei Fragen wenden Sie sich an den Administrator.\n\n"
            "Dr√ºcken Sie die Schaltfl√§che unten, um den Bedingungen zuzustimmen."
        )
        agree_text = "‚úÖ Ich stimme den Bedingungen zu"

    builder = InlineKeyboardBuilder()
    builder.button(text=agree_text, callback_data="agree")

    await callback.message.edit_text(
        text,
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await state.set_state(OnboardingStates.waiting_for_agreement)
    await callback.answer()

# Agreement callback
@router.callback_query(OnboardingStates.waiting_for_agreement, F.data == "agree")
async def process_agreement(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    language = data.get("language_pref", "uk")
    telegram_name = data.get("full_name", "User")

    # Show success message and suggest Telegram name
    if language == "uk":
        text = (
            "‚úÖ <b>–î—è–∫—É—î–º–æ –∑–∞ –∑–≥–æ–¥—É!</b>\n\n"
            f"üë§ –ú–∏ –±–∞—á–∏–º–æ –≤–∞—Å —è–∫: <b>{telegram_name}</b>\n\n"
            "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Ü–µ —ñ–º'—è –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω—å?"
        )
        yes_text = "‚úÖ –¢–∞–∫, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Ü–µ —ñ–º'—è"
        change_text = "‚úèÔ∏è –ó–º—ñ–Ω–∏—Ç–∏ —ñ–º'—è"
    else:
        text = (
            "‚úÖ <b>Vielen Dank f√ºr Ihre Zustimmung!</b>\n\n"
            f"üë§ Wir sehen Sie als: <b>{telegram_name}</b>\n\n"
            "Dieses Namen f√ºr Bestellungen verwenden?"
        )
        yes_text = "‚úÖ Ja, diesen Namen verwenden"
        change_text = "‚úèÔ∏è Namen √§ndern"

    builder = InlineKeyboardBuilder()
    builder.button(text=yes_text, callback_data="name_yes")
    builder.button(text=change_text, callback_data="name_change")

    await callback.message.edit_text(
        text,
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await state.set_state(OnboardingStates.waiting_for_name_confirmation)
    await callback.answer()

# Name confirmation handlers
@router.callback_query(OnboardingStates.waiting_for_name_confirmation, F.data == "name_yes")
async def process_name_yes(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    telegram_name = data.get("full_name", "User")

    # Use Telegram name
    await state.update_data(real_name=telegram_name)
    await proceed_to_phone(callback.message, state)
    await callback.answer()

@router.callback_query(OnboardingStates.waiting_for_name_confirmation, F.data == "name_change")
async def process_name_change(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    language = data.get("language_pref", "uk")

    if language == "uk":
        text = "üë§ <b>–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —Å–ø—Ä–∞–≤–∂–Ω—î —ñ–º'—è —Ç–∞ –ø—Ä—ñ–∑–≤–∏—â–µ:</b>\n\n–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –Ü–≤–∞–Ω –ü–µ—Ç—Ä–µ–Ω–∫–æ"
    else:
        text = "üë§ <b>Geben Sie Ihren vollst√§ndigen Namen ein:</b>\n\nBeispiel: Ivan Petrenko"

    await callback.message.edit_text(text, parse_mode="HTML")
    await state.set_state(OnboardingStates.waiting_for_name_input)
    await callback.answer()

# Name input handler
@router.message(OnboardingStates.waiting_for_name_input)
async def process_name(message: Message, state: FSMContext):
    name = message.text.strip()

    if len(name) < 2:
        data = await state.get_data()
        language = data.get("language_pref", "uk")

        if language == "uk":
            await message.answer("‚ùå –Ü–º'—è –ø–æ–≤–∏–Ω–Ω–æ –º—ñ—Å—Ç–∏—Ç–∏ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ 2 —Å–∏–º–≤–æ–ª–∏. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:")
        else:
            await message.answer("‚ùå Der Name muss mindestens 2 Zeichen enthalten. Versuchen Sie es erneut:")
        return

    await state.update_data(real_name=name)
    await proceed_to_phone(message, state)

# Phone input handler (both contact and text)
@router.message(OnboardingStates.waiting_for_phone, F.contact)
async def process_phone_contact(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await finalize_onboarding(message, state, phone)

@router.message(OnboardingStates.waiting_for_phone)
async def process_phone_text(message: Message, state: FSMContext):
    phone = message.text.strip()

    # Basic phone validation
    if not phone or len(phone) < 7:
        data = await state.get_data()
        language = data.get("language_pref", "uk")

        if language == "uk":
            await message.answer("‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É:")
        else:
            await message.answer("‚ùå Bitte geben Sie eine g√ºltige Telefonnummer ein:")
        return

    await finalize_onboarding(message, state, phone)

async def proceed_to_phone(message: Message, state: FSMContext):
    # Request phone number
    data = await state.get_data()
    language = data.get("language_pref", "uk")

    if language == "uk":
        text = "üì± <b>–ù–∞–¥—ñ—à–ª—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É:</b>\n\n–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ –∞–±–æ –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –≤—Ä—É—á–Ω—É."
        button_text = "üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"
    else:
        text = "üì± <b>Senden Sie Ihre Telefonnummer:</b>\n\nDr√ºcken Sie die Schaltfl√§che unten oder geben Sie die Nummer manuell ein."
        button_text = "üì± Telefonnummer senden"

    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=button_text, request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(OnboardingStates.waiting_for_phone)

async def finalize_onboarding(message: Message, state: FSMContext, phone: str):
    data = await state.get_data()

    try:
        async with async_session() as session:
            # Get or create user
            user = await session.scalar(select(User).where(User.tg_id == data["tg_id"]))

            if not user:
                user = User(
                    tg_id=data["tg_id"],
                    full_name=data["full_name"]
                )
                session.add(user)

            # Update user data
            user.language_pref = data["language_pref"]
            user.full_name = data["real_name"]  # Override with real name
            user.phone = phone

            await session.commit()

        # Clear state
        await state.clear()

        # Show success message and main menu
        language = data.get("language_pref", "uk")
        main_menu = await get_main_menu_keyboard(language)
        welcome_text = await get_translation("welcome_message", language)

        if language == "uk":
            success_text = (
                "üéâ <b>–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                "‚úÖ –í–∞—à—ñ –¥–∞–Ω—ñ –∑–±–µ—Ä–µ–∂–µ–Ω–æ. –¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–≥–ª—è–¥–∞—Ç–∏ –∫–∞—Ç–∞–ª–æ–≥ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ —Ç–∞ —Ä–æ–±–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.\n\n"
                "üë§ –í–∏ –º–æ–∂–µ—Ç–µ –∑–º—ñ–Ω–∏—Ç–∏ —Å–≤–æ—ó –¥–∞–Ω—ñ –≤ —Ä–æ–∑–¥—ñ–ª—ñ <b>–ü—Ä–æ—Ñ—ñ–ª—å</b>."
            )
        else:
            success_text = (
                "üéâ <b>Registrierung abgeschlossen!</b>\n\n"
                "‚úÖ Ihre Daten wurden gespeichert. Sie k√∂nnen jetzt den Produktkatalog durchsuchen und Bestellungen aufgeben.\n\n"
                "üë§ Sie k√∂nnen Ihre Daten im Bereich <b>Profil</b> √§ndern."
            )

        await message.answer(success_text, reply_markup=main_menu, parse_mode="HTML")

    except Exception as e:
        await message.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ –¥–∞–Ω–∏—Ö. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")

# Impressum handler
@router.message(TranslationFilter("impressum_button"))
async def handle_impressum_message(message: Message):
    """Handle impressum button clicks in both languages."""
    await impressum_handler(message)

async def impressum_handler(message: Message):
    try:
        async with async_session() as session:
            # Get impressum from StaticPage table
            impressum_page = await session.scalar(
                select(StaticPage).where(StaticPage.slug == "impressum")
            )

            if impressum_page:
                # Get user language preference
                user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
                language = user.language_pref if user else "uk"

                if language == "uk":
                    title = impressum_page.title_uk or impressum_page.title
                    content = impressum_page.content_uk or impressum_page.content
                else:
                    title = impressum_page.title_de or impressum_page.title
                    content = impressum_page.content_de or impressum_page.content

                text = f"<b>{title}</b>\n\n{content}"
            else:
                text = "‚ÑπÔ∏è <b>Impressum</b>\n\n–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –∫–æ–º–ø–∞–Ω—ñ—é –±—É–¥–µ –¥–æ–¥–∞–Ω–∞ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º."

            await message.answer(text, parse_mode="HTML")

    except Exception as e:
        await message.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó.")

# Profile handler
@router.message(TranslationFilter("profile_button"))
async def handle_profile_message(message: Message):
    """Handle profile button clicks in both languages."""
    await profile_handler(message)

async def profile_handler(message: Message):
    """Show user profile with balance, name, phone and language toggle."""
    try:
        async with async_session() as session:
            user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))

            if not user:
                await message.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                return

            # Get localized labels
            user_language = user.language_pref or "uk"

            name_label = await get_translation("name_label", user_language)
            phone_label = await get_translation("phone_label", user_language)
            balance_label = await get_translation("balance_label", user_language)
            change_lang_btn = await get_translation("change_lang_btn", user_language)

            # Format profile message
            profile_text = f"üë§ <b>{await get_translation('profile_title', user_language)}</b>\n\n"
            profile_text += f"{name_label}: {user.full_name or '–ù–µ –≤–∫–∞–∑–∞–Ω–æ'}\n"
            profile_text += f"{phone_label}: {user.phone or '–ù–µ –≤–∫–∞–∑–∞–Ω–æ'}\n"
            profile_text += f"{balance_label}: {user.balance:.2f} ‚Ç¨\n"

            # Create inline keyboard with language toggle
            builder = InlineKeyboardBuilder()
            builder.button(text=change_lang_btn, callback_data="toggle_language")

            await message.answer(
                profile_text,
                reply_markup=builder.as_markup(),
                parse_mode="HTML"
            )

    except Exception as e:
        await message.answer("–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø—Ä–æ—Ñ—ñ–ª—é.")

# Language toggle callback
@router.callback_query(F.data == "toggle_language")
async def toggle_language(callback: CallbackQuery):
    """Toggle user's language preference between UK and DE."""
    try:
        async with async_session() as session:
            user = await session.scalar(select(User).where(User.tg_id == callback.from_user.id))

            if not user:
                await callback.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                return

            # Toggle language
            new_language = "de" if user.language_pref == "uk" else "uk"
            user.language_pref = new_language

            await session.commit()

            # Get confirmation message in new language
            if new_language == "de":
                confirm_msg = "Sprache zu Deutsch gewechselt! üá©üá™"
            else:
                confirm_msg = "–ú–æ–≤—É –∑–º—ñ–Ω–µ–Ω–æ –Ω–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É! üá∫üá¶"

            await callback.answer(confirm_msg, show_alert=True)

            # Refresh the profile view with updated language
            await profile_handler(callback.message)

            # Send updated main menu in new language
            main_menu = await get_main_menu_keyboard(new_language)
            welcome_text = await get_translation("welcome_message", new_language)
            await callback.message.answer(f"{welcome_text} –û–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–¥—ñ–ª –Ω–∏–∂—á–µ üëá", reply_markup=main_menu)

    except Exception as e:
        await callback.answer("–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–º—ñ–Ω—ñ –º–æ–≤–∏.")
</file>

<file path="core/models.py">
from sqlalchemy import Column, Integer, String, Float, Boolean, Text, BigInteger, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from .database import Base
import datetime
from enum import Enum as PyEnum
from flask_login import UserMixin

class OrderStatus(PyEnum):
    NEW = "NEW"
    VERIFIED = "VERIFIED"
    PROCUREMENT = "PROCUREMENT"
    IN_DELIVERY = "IN_DELIVERY"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"

class LanguagePref(PyEnum):
    uk = "uk"
    de = "de"

class AvailabilityStatus(PyEnum):
    IN_STOCK = "IN_STOCK"
    OUT_OF_STOCK = "OUT_OF_STOCK"
    ON_REQUEST = "ON_REQUEST"

class TransactionType(PyEnum):
    DEPOSIT = "DEPOSIT"
    PAYMENT = "PAYMENT"
    REFUND = "REFUND"

class TransactionStatus(PyEnum):
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class User(Base, UserMixin):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    tg_id = Column(BigInteger, unique=True, index=True)
    full_name = Column(String)
    email = Column(String, unique=True)
    username = Column(String, unique=True)
    password_hash = Column(String, nullable=True)
    phone = Column(String, nullable=True)
    address = Column(Text)
    is_trusted = Column(Boolean, default=False)
    is_admin = Column(Boolean, default=False)
    language_pref = Column(Enum(LanguagePref), default=LanguagePref.de)
    admin_notes = Column(Text)
    balance = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

    orders = relationship("Order", back_populates="user")
    transactions = relationship("Transaction", back_populates="user")
    cart_items = relationship("CartItem", back_populates="user")

    def __str__(self):
        return self.full_name or self.username or f"User {self.id}"

class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Float)
    type = Column(Enum(TransactionType))
    status = Column(Enum(TransactionStatus))
    external_id = Column(String)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

    user = relationship("User", back_populates="transactions")

    def __str__(self):
        return f"Transaction {self.id}: {self.type.value} {self.amount}"

class CartItem(Base):
    __tablename__ = "cart_items"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Float, default=1.0)

    user = relationship("User", back_populates="cart_items")
    product = relationship("Product", back_populates="cart_items")

    def __str__(self):
        return f"CartItem {self.id}: {self.product.name} x{self.quantity}"

class OrderItem(Base):
    __tablename__ = "order_items"

    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Float)
    final_weight = Column(Float, nullable=True)
    price_at_time = Column(Float)

    order = relationship("Order", back_populates="items")
    product = relationship("Product", back_populates="order_items")

    def __str__(self):
        return f"OrderItem {self.id}: {self.product.name} x{self.quantity}"

class Farm(Base):
    __tablename__ = "farms"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, nullable=False)
    description_uk = Column(Text, nullable=True)
    description_de = Column(Text, nullable=True)
    location = Column(String(255), nullable=True)
    contact_info = Column(String(255), nullable=True)
    is_active = Column(Boolean, default=True)
    image_path = Column(String(255), nullable=True)

    products = relationship("Product", back_populates="farm")

    def __str__(self):
        return self.name

class Product(Base):
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    name_de = Column(String)
    price = Column(Float)
    unit = Column(String, default='kg')
    sku = Column(String(50), unique=True, nullable=True)
    availability_status = Column(Enum(AvailabilityStatus), default=AvailabilityStatus.IN_STOCK)
    description = Column(Text)
    description_de = Column(Text)
    category_id = Column(Integer, ForeignKey("categories.id"))
    farm_id = Column(Integer, ForeignKey("farms.id"), nullable=True)
    image_path = Column(String(255), nullable=True)

    category = relationship("Category", back_populates="products")
    farm = relationship("Farm", back_populates="products")
    cart_items = relationship("CartItem", back_populates="product")
    order_items = relationship("OrderItem", back_populates="product")

    def __str__(self):
        return f"{self.name} ({self.farm.name if self.farm else 'No Farm'})"

class Category(Base):
    __tablename__ = "categories"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    name_de = Column(String)
    slug = Column(String, unique=True)
    image_url = Column(String)
    description = Column(Text)
    description_de = Column(Text)
    image_path = Column(String(255), nullable=True)

    products = relationship("Product", back_populates="category")

    def __str__(self):
        return self.name

class Order(Base):
    __tablename__ = "orders"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    status = Column(Enum(OrderStatus), default=OrderStatus.NEW)
    total_price = Column(Float)
    delivery_address = Column(Text)
    contact_phone = Column(String)
    delivery_slot = Column(String)
    comment = Column(Text)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

    user = relationship("User", back_populates="orders")
    items = relationship("OrderItem", back_populates="order")

class StaticPage(Base):
    __tablename__ = "static_pages"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    title_de = Column(String)
    slug = Column(String, unique=True)
    content = Column(Text)
    content_de = Column(Text)
    seo_title_uk = Column(String)
    seo_title_de = Column(String)
    seo_description_uk = Column(Text)
    seo_description_de = Column(Text)

class GlobalSettings(Base):
    __tablename__ = "global_settings"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String, unique=True)
    value = Column(Text)

class Translation(Base):
    __tablename__ = "translations"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String, unique=True)
    value_uk = Column(Text)
    value_de = Column(Text)
</file>

</files>
